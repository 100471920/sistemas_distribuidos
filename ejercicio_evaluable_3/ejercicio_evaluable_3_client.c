/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "ejercicio_evaluable_3.h"


void
innit_prog_1(char *host)
{
	CLIENT *clnt;
	enum clnt_stat retval_1;
	int result_1;
	char *innit_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, INNIT_PROG, INNIT_VERSION, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	retval_1 = innit_1((void*)&innit_1_arg, &result_1, clnt);
	if (retval_1 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
        clnt_destroy (clnt);
	}
    printf("Resultado de la operación: %d\n", result_1);
#ifndef	DEBUG
#endif	 /* DEBUG */
}


void
set_value_prog_2(char *host)
{
	CLIENT *clnt;
	enum clnt_stat retval_1;
	int result_1;
	struct mensaje  set_value_2_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, SET_VALUE_PROG, SET_VALUE_VERSION, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

    printf("Indique la clave sobre la que se desea hacer set_value(key, valor_1, num_elements, vector): key = ");
    if ((scanf("%d", &set_value_2_arg.key)) != 1){
        perror("[ERROR] El valor de key debe ser un int\n");
    }
    else {
        printf("Indique el valor 1 para set_value(key, valor_1, num_elements, vector): valor_1 = ");
        set_value_2_arg.val_1 = (char*)malloc(256 * sizeof(char));
        scanf("%s", set_value_2_arg.val_1);
        printf("Indique el numero de elementos de valor 2 para set_value(key, valor_1, num_elements, vector): num_elements = ");
        if ((scanf("%d", &set_value_2_arg.vector.vector_len)) != 1){
            perror("[ERROR] El valor de num_elements debe ser un int\n");
        }  else {
            set_value_2_arg.vector.vector_val = (double*)malloc(set_value_2_arg.vector.vector_len * sizeof(double));
            for (int i = 0; i < set_value_2_arg.vector.vector_len; i++) {
                printf("Indique el elemento para set_value(key, valor_1, num_elements, vector): vector[%d] = ",i);
                if ((scanf("%lf", &set_value_2_arg.vector.vector_val[i])) != 1) {
                    perror("[ERROR] El valor de los elementos del vector debe ser un double\n");
                    break;
                }
            }
        }
    }
    retval_1 = set_value_2(&set_value_2_arg, &result_1, clnt);
    if (retval_1 != RPC_SUCCESS) {
        clnt_perror (clnt, "call failed");
        clnt_destroy (clnt);
    }

#ifndef	DEBUG
#endif	 /* DEBUG */
}


void
get_value_prog_3(char *host)
{
	CLIENT *clnt;
	enum clnt_stat retval_1;
	struct mensaje result_1;
	int  get_value_3_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, GET_VALUE_PROG, GET_VALUE_VERSION, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

    printf("Indique la clave sobre la que se desea hacer get_value(key): key = ");
    if ((scanf("%d", &get_value_3_arg)) != 1){
        perror("[ERROR] El valor de key debe ser un int\n");
        exit(-1);
    }

    result_1.val_1 = (char *)malloc(256 * sizeof(char));

    result_1.vector.vector_val = (double *)malloc(32 * sizeof(double));

    retval_1 = get_value_3(&get_value_3_arg, &result_1, clnt);
    if (retval_1 != RPC_SUCCESS) {
        clnt_perror (clnt, "call failed");
        clnt_destroy (clnt);
    }
    if(result_1.key != -1){
    printf("key = %d\n", get_value_3_arg);
    printf("val_1 = %s\n", result_1.val_1);
    printf("n_elem = %d\n", result_1.vector.vector_len);
    for(int i = 0; i < result_1.vector.vector_len; i++){
        printf("vector[%d] = %lf\n", i, result_1.vector.vector_val[i]);
    }}
    printf("resultado = %d\n", result_1.key);

#ifndef	DEBUG
#endif	 /* DEBUG */
}


void
modify_value_prog_4(char *host)
{
	CLIENT *clnt;
	enum clnt_stat retval_1;
	int result_1;
	struct mensaje  modify_value_4_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, MODIFY_VALUE_PROG, MODIFY_VALUE_VERSION, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

    printf("Indique la clave sobre la que se desea hacer modify_value(key, valor_1, num_elements, vector): key = ");
    if ((scanf("%d", &modify_value_4_arg.key)) != 1){
        perror("[ERROR] El valor de key debe ser un int\n");
    } else {
        printf("Indique el valor 1 para modify_value(key, valor_1, num_elements, vector): valor_1 = ");
        modify_value_4_arg.val_1 = (char*)malloc(256 * sizeof(char));
        scanf("%s", modify_value_4_arg.val_1);
        printf("Indique el numero de elementos de valor 2 para modify_value(key, valor_1, num_elements, vector): num_elements = ");
        if ((scanf("%d", &modify_value_4_arg.vector.vector_len)) != 1){
            perror("[ERROR] El valor de num_elements debe ser un int\n");
        }  else {
            modify_value_4_arg.vector.vector_val = (double*)malloc(modify_value_4_arg.vector.vector_len * sizeof(double));
            for (int i = 0; i < modify_value_4_arg.vector.vector_len; i++) {
                printf("Indique el elemento para modify_value(key, valor_1, num_elements, vector): vector[%d] = ",i);
                if ((scanf("%lf", &modify_value_4_arg.vector.vector_val[i])) != 1) {
                    perror("[ERROR] El valor de los elementos del vector debe ser un double\n");
                    break;
                }
            }
        }
    }
    retval_1 = modify_value_4(&modify_value_4_arg, &result_1, clnt);
    if (retval_1 != RPC_SUCCESS) {
        clnt_perror (clnt, "call failed");
        clnt_destroy (clnt);
    }
    printf("Resultado = %d\n", result_1);

#ifndef	DEBUG
#endif	 /* DEBUG */
}


void
delete_key_prog_5(char *host)
{
	CLIENT *clnt;
	enum clnt_stat retval_1;
	int result_1;
	int  delete_key_5_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, DELETE_KEY_PROG, DELETE_KEY_VERSION, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

    printf("Indique la clave sobre la que se desea hacer get_value(key): key = ");
    if ((scanf("%d", &delete_key_5_arg)) != 1){
        perror("[ERROR] El valor de key debe ser un int\n");
        exit(-1);
    }
	retval_1 = delete_key_5(&delete_key_5_arg, &result_1, clnt);
	if (retval_1 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
        clnt_destroy (clnt);
	}
    printf("Resultado = %d\n",result_1);
#ifndef	DEBUG

#endif	 /* DEBUG */
}


void
exist_prog_6(char *host)
{
	CLIENT *clnt;
	enum clnt_stat retval_1;
	int result_1;
	int  exist_6_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, EXIST_PROG, EXIST_VERSION, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
    printf("Indique la clave sobre la que se desea hacer exist(key): key = ");
    if ((scanf("%d", &exist_6_arg)) != 1){
        perror("[ERROR] El valor de key debe ser un int\n");
        exit(-1);
    }
	retval_1 = exist_6(&exist_6_arg, &result_1, clnt);
	if (retval_1 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
        clnt_destroy (clnt);
	}
    printf("Resultado = %d\n", result_1);
#ifndef	DEBUG

#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
    char *host;


    if (argc < 2) {
        printf ("usage: %s server_host\n", argv[0]);
        exit (1);
    }
    host = argv[1];
    char peticion[20];
    while(1) {
        printf("Indique la operación a realizar: ");
        // El usuario introduce por terminal la operación
        scanf("%s", peticion);
        if (strcmp(peticion,"init") == 0) {
            innit_prog_1 (host);
        }
        else if (strcmp(peticion, "set_value") == 0){
            set_value_prog_2 (host);
        }
        else if (strcmp(peticion, "get_value") == 0){
            get_value_prog_3 (host);
        }
        else if (strcmp(peticion, "modify_value") == 0){
            modify_value_prog_4 (host);
        }
        else if (strcmp(peticion, "delete_key") == 0){
            delete_key_prog_5(host);
        }
        else if (strcmp(peticion, "exist") == 0){
            exist_prog_6(host);
        }
    }
    exit (0);

}
